package me.spruce.creeperclient.module.modules.exploits;

import com.mojang.realmsclient.gui.ChatFormatting;
import me.spruce.creeperclient.command.Command;
import me.spruce.creeperclient.module.Category;
import me.spruce.creeperclient.module.Module;
import me.spruce.creeperclient.setting.n.Setting;
import net.minecraft.block.Block;
import net.minecraft.client.gui.inventory.GuiInventory;
import net.minecraft.init.Blocks;
import net.minecraft.inventory.ClickType;
import net.minecraft.item.Item;
import net.minecraft.item.ItemBlock;
import net.minecraft.item.ItemStack;
import net.minecraft.item.crafting.CraftingManager;
import net.minecraft.item.crafting.IRecipe;
import net.minecraft.network.play.client.CPacketPlaceRecipe;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent;
import org.lwjgl.input.Keyboard;

import java.util.ArrayList;
import java.util.Arrays;

/*
*   Skidded from AutoDupe (Lambda Plugin)
*/
@SuppressWarnings("all")
public class DupeItem5b5t extends Module {

    public Setting<Boolean> cancelGUI = register("Cancel GUI", true);
    public Setting<String> interacting = register("Rotation Mode", Arrays.asList("OFF", "SPOOF", "VIEW_LOCK"), "VIEW_LOCK");

    public DupeItem5b5t() {
        super("5b5t Item Dupe", "Dupes Items on 5b5t", Keyboard.KEY_NONE, Category.EXPLOITS);
    }

    private WaitPhase currentWaitPhase;
    private long startTimeStamp = 0L;
    private int countBefore = 0;
    private int idBefore = 0;
    private int slotBefore = 0;
    private long lastClickStamp = System.currentTimeMillis();
    private ResourceLocation recipeLocation = new ResourceLocation("wooden_button");
    private IRecipe pktRecipe = CraftingManager.REGISTRY.getObject(recipeLocation);

    @Override
    public void onEnable() {
        int check = checkForPlanks();
        if (check == -1) {
            Command.sendMessage(ChatFormatting.DARK_RED + "Planks were not found in inventory.");
            currentWaitPhase = WaitPhase.NONE;
        } else currentWaitPhase = WaitPhase.DROP;

        super.onEnable();
    }

    @Override
    public void onDisable() {
        if (cancelGUI.getValue()) mc.displayGuiScreen(null);

        super.onDisable();
    }

    private boolean called = false;

    @SubscribeEvent
    public void onTick(TickEvent.ClientTickEvent event) {
        if (currentWaitPhase == WaitPhase.NONE) {
            toggle();
            return;
        }

        if (currentWaitPhase == WaitPhase.DROP && !called) {
            called = true;

            if (mc.player.inventory.getCurrentItem().isEmpty()) {
                Command.sendMessage(ChatFormatting.DARK_RED + "You need to hold an item.");
                currentWaitPhase = WaitPhase.NONE;
                return;
            }

            if (System.currentTimeMillis() - startTimeStamp < 120L) {
                if (!mc.player.getRecipeBook().isGuiOpen()) mc.player.getRecipeBook().setGuiOpen(true);
            }

            updateRotation();

            idBefore = Item.getIdFromItem(mc.player.inventory.getCurrentItem().getItem());
            countBefore = countItem(idBefore);
            slotBefore = mc.player.inventory.currentItem;
            throwAllInSlot(slotBefore + 36);

            if (!cancelGUI.getValue()) mc.displayGuiScreen(new GuiInventory(mc.player));
            if (!mc.player.getRecipeBook().isGuiOpen()) {
                Command.sendMessage("Failed to open Recipe Book. Try opening it manually.");
                return;
            }

            currentWaitPhase = WaitPhase.PICKUP;
            called = false;
        } else if (currentWaitPhase == WaitPhase.PICKUP) {
            if (System.currentTimeMillis() - lastClickStamp < 300L) toggle();
            lastClickStamp = System.currentTimeMillis();
        }
    }

    private int checkForPlanks() {
        for (int i = 0; i < 35; i++) {
            ItemStack stack = mc.player.inventory.getStackInSlot(i);
            if (stack.getItem() instanceof ItemBlock) {
                Block block = ((ItemBlock) stack.getItem()).getBlock();
                if (block == Blocks.PLANKS) {
                    return i;
                }
            }
        }
        return -1;
    }

    private void updateRotation() {
        if (RotationMode.VIEW_LOCK.name().equals(interacting.getValue())) {
            mc.player.rotationPitch = 180f;
        } else if (RotationMode.SPOOF.name().equals(interacting.getValue())) {
            mc.getConnection().sendPacket(new CPacketPlayer.Rotation(mc.player.rotationYaw, 180f, true));
        }
    }

    private int countItem(int itemId) {
        ArrayList<Integer> itemList = getSlots(itemId);
        int currentCount = 0;
        for (int i : itemList) {
            currentCount += mc.player.inventory.getStackInSlot(i).getCount();
        }
        return currentCount;
    }

    private ArrayList<Integer> getSlots(int itemID) {
        ArrayList<Integer> slots = new ArrayList<>();
        for (int i = 0; i < 8; i++) {
            if (Item.getIdFromItem(mc.player.inventory.getStackInSlot(i).getItem()) == itemID) slots.add(i);
        }
        return slots;
    }

    private void throwAllInSlot(int slot) {
        new Thread(() -> {
            mc.playerController.windowClick(mc.player.inventoryContainer.windowId, slot, 1, ClickType.THROW, mc.player);
            try {
                Thread.sleep(1000L);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            mc.getConnection().sendPacket(new CPacketPlaceRecipe(0, pktRecipe, false));
        }).start();
    }

    enum WaitPhase {
        NONE, DROP, PICKUP
    }

    enum RotationMode {
        OFF, SPOOF, VIEW_LOCK
    }
}
